
#include <Arduino.h>
#include <ArduinoOTA.h>
#include <WiFi.h>
#include <ESPmDNS.h>
#include <WiFiUdp.h>
#include <U8x8lib.h>
#include <U8g2lib.h>
#include <analogWrite.h>
#include <ESP32RotaryEncoder.h>

#ifdef U8X8_HAVE_HW_SPI
#include <SPI.h>
#endif

// Encoder pins
const uint8_t DI_ENCODER_A   = 2;
const uint8_t DI_ENCODER_B   = 4;
long counter = 0;

// WiFi SSID & Password
const char* ssid = "VICTUS 0978";
const char* password = "5Vr7434/";

U8X8_SH1106_128X64_NONAME_HW_I2C u8x8(/* reset=*/ U8X8_PIN_NONE);
U8G2_SH1106_128X64_NONAME_F_HW_I2C u8g2(U8G2_R0, /* reset=*/ U8X8_PIN_NONE);
RotaryEncoder rotaryEncoder( DI_ENCODER_A, DI_ENCODER_B);


const unsigned char myBitmap [] PROGMEM = {
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x03, 0x80, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x03, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x00,
0x03, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x7c, 0x00, 0x03, 0xfc, 0x00, 0x00, 0x00, 0x01, 0xfc, 0x00,
0x03, 0xff, 0x00, 0x00, 0x00, 0x07, 0xfc, 0x00, 0x03, 0xff, 0xc0, 0x00, 0x00, 0x1f, 0xfc, 0x00,
0x03, 0xff, 0xf0, 0x00, 0x00, 0x3f, 0xfc, 0x00, 0x03, 0xff, 0xfc, 0x00, 0x00, 0xff, 0xfc, 0x00,
0x03, 0xff, 0xfe, 0x00, 0x03, 0xff, 0xfc, 0x00, 0x03, 0xff, 0xff, 0x80, 0x0f, 0xff, 0xfc, 0x00,
0x03, 0xff, 0xff, 0xe0, 0x1f, 0xff, 0xfc, 0x00, 0x03, 0xff, 0xff, 0xf8, 0x7f, 0xff, 0xfc, 0x00,
0x03, 0xff, 0xff, 0xfd, 0xff, 0xff, 0xfc, 0x00, 0x03, 0xff, 0xff, 0xf3, 0xff, 0xff, 0xfc, 0x00,
0x03, 0xff, 0xff, 0xcf, 0xff, 0xff, 0xfc, 0x00, 0x03, 0xff, 0xff, 0x3f, 0xff, 0xc3, 0xfc, 0x00,
0x03, 0xff, 0xfe, 0x7f, 0xff, 0xc1, 0xfc, 0x00, 0x03, 0xff, 0xf9, 0xff, 0xff, 0xc1, 0xfc, 0x00,
0x03, 0xff, 0xe7, 0xff, 0xff, 0xc1, 0xfc, 0x00, 0x03, 0xff, 0xdf, 0xff, 0xff, 0xe3, 0xfc, 0x00,
0x03, 0xff, 0x7f, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x03, 0xfd, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00,
0x03, 0xf3, 0xff, 0xff, 0xff, 0xc3, 0xfc, 0x00, 0x03, 0xcf, 0xff, 0xff, 0xff, 0xc3, 0xfc, 0x00,
0x03, 0xbf, 0xff, 0xff, 0xff, 0xc3, 0xfc, 0x00, 0x02, 0xff, 0xff, 0xff, 0xff, 0xc3, 0xfc, 0x00,
0x01, 0xff, 0xff, 0xff, 0xff, 0xc3, 0xf8, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xc3, 0xf0, 0x00,
0x00, 0x3f, 0xff, 0xff, 0xff, 0xc3, 0xc0, 0x00, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xc3, 0x00, 0x00,
0x00, 0x07, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x00,
0x00, 0x00, 0x7f, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xc0, 0x00, 0x00,
0x00, 0x00, 0x0f, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0xfc, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xc0, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x1f, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0xde, 0xef, 0xbb, 0xb9, 0x57, 0x77, 0xfd, 0x70, 0x5a, 0xab, 0xba, 0xa9, 0x75, 0xd7, 0xd5, 0x50,
0x5a, 0x89, 0xba, 0xa9, 0x75, 0xd7, 0xd9, 0x50, 0x6e, 0x69, 0xbb, 0xb9, 0x75, 0xd7, 0xed, 0x70,
0x6e, 0x29, 0xbb, 0xa9, 0x55, 0xd7, 0xc5, 0x70, 0x6a, 0xab, 0xba, 0xa9, 0x55, 0xd7, 0xd5, 0x50,
0x6a, 0xee, 0xde, 0xa9, 0x57, 0x77, 0xfd, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

const unsigned char myBitmapRev [] PROGMEM = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0xC0, 0x03, 0x00, 0x00, 
  0x00, 0x00, 0x18, 0x00, 0x80, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x1E, 0x00, 
  0xC0, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x00, 0xC0, 0x7F, 0x00, 0x00, 
  0x00, 0xC0, 0x1F, 0x00, 0xC0, 0xFF, 0x01, 0x00, 0x00, 0xF0, 0x1F, 0x00, 
  0x80, 0xFF, 0x07, 0x00, 0x00, 0xF8, 0x3F, 0x00, 0x80, 0xFF, 0x0F, 0x00, 
  0x00, 0xFE, 0x1F, 0x00, 0xC0, 0xFF, 0x3F, 0x00, 0x80, 0xFF, 0x1F, 0x00, 
  0xC0, 0xFF, 0xFF, 0x00, 0xE0, 0xFF, 0x1F, 0x00, 0xC0, 0xFF, 0xFF, 0x03, 
  0xF0, 0xFF, 0x1F, 0x00, 0xC0, 0xFF, 0xFF, 0x0F, 0xFC, 0xFF, 0x3F, 0x00, 
  0x80, 0xFF, 0xFF, 0x1F, 0xFE, 0xFF, 0x1F, 0x00, 0x80, 0xFF, 0xFF, 0x9F, 
  0xFF, 0xFF, 0x1F, 0x00, 0xC0, 0xFF, 0xFF, 0xE7, 0xFF, 0xFF, 0x1F, 0x00, 
  0xC0, 0xFF, 0xFF, 0xF3, 0xFF, 0xC7, 0x1F, 0x00, 0xC0, 0xFF, 0xFF, 0xFC, 
  0xFF, 0xC3, 0x3F, 0x00, 0xC0, 0xFF, 0x3F, 0xFF, 0xFF, 0x81, 0x1F, 0x00, 
  0x80, 0xFF, 0xCF, 0xFF, 0xFF, 0x83, 0x1F, 0x00, 0xC0, 0xFF, 0xE7, 0xFF, 
  0xFF, 0x83, 0x1F, 0x00, 0xC0, 0xFF, 0xF9, 0xFF, 0xFF, 0xC7, 0x1F, 0x00, 
  0xC0, 0x7F, 0xFE, 0xFF, 0xFF, 0xFF, 0x1F, 0x00, 0x80, 0x3F, 0xFF, 0xFF, 
  0xFF, 0x83, 0x1F, 0x00, 0xC0, 0xCF, 0xFF, 0xFF, 0xFF, 0xC3, 0x1F, 0x00, 
  0xC0, 0xF3, 0xFF, 0xFF, 0xFF, 0xC3, 0x1F, 0x00, 0xC0, 0xF9, 0xFF, 0xFF, 
  0xFF, 0xC3, 0x1F, 0x00, 0x00, 0xFE, 0xFF, 0xFF, 0xFF, 0x83, 0x1F, 0x00, 
  0x80, 0xFF, 0xFF, 0xFF, 0xFF, 0xC3, 0x1F, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xC3, 0x07, 0x00, 0x00, 0xFC, 0xFF, 0xFF, 0xFF, 0xC3, 0x03, 0x00, 
  0x00, 0xF0, 0xFF, 0xFF, 0xFF, 0x83, 0x00, 0x00, 0x00, 0xC0, 0xFF, 0xFF, 
  0xFF, 0x03, 0x00, 0x00, 0x00, 0x80, 0xFF, 0xFF, 0xFF, 0x03, 0x00, 0x00, 
  0x00, 0x00, 0xFE, 0xFF, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00, 0xFC, 0xFF, 
  0xFF, 0x01, 0x00, 0x00, 0x00, 0x00, 0xF0, 0xFF, 0xFF, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0xC0, 0xFF, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 
  0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x03, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0xF8, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x68, 0xB6, 0x89, 0x9C, 
  0x6A, 0x46, 0xB7, 0x06, 0x5A, 0x55, 0x54, 0x97, 0xAA, 0x7A, 0xA9, 0x0A, 
  0xBA, 0x91, 0x55, 0x94, 0xAA, 0x69, 0x89, 0x06, 0x0A, 0x13, 0x45, 0x95, 
  0xAE, 0xEA, 0x9B, 0x0A, 0x66, 0x96, 0xC4, 0x9D, 0xAE, 0x58, 0xA1, 0x0E, 
  0x76, 0x14, 0x55, 0x95, 0xAA, 0x6A, 0xA0, 0x05, 0x56, 0xD5, 0x55, 0x95, 
  0xEA, 0x5E, 0xBB, 0x0A, 0x00, 0x12, 0x13, 0x80, 0x28, 0x02, 0x14, 0x00
};

void knobCallback( long value )
{
  counter = counter+value;
  Serial.printf( "Value: %ld\n", counter );
}

 #define encUA 2
 #define encUB 4

 int counter = 0; 
 int aState;
 int aLastState;  
 bool stateSwitch = false;
 int lastCounter=0;
 int pullSpeed=0;
 int lengthCatheter=0;

void readSwitch()
{
    if(!digitalRead(16))
   {
    if(!stateSwitch)
    {
      stateSwitch = true;
    }
    else
    {
      stateSwitch = false;
    }
   }
}

void encRead()
{     
   readSwitch();
   aState = digitalRead(encUA); // Reads the "current" state of the outputA
   // If the previous and the current state of the outputA are different, that means a Pulse has occured
   if (aState != aLastState){     
     // If the outputB state is different to the outputA state, that means the encoder is rotating clockwise
     if (digitalRead(encUB) != aState) { 
       counter ++;
     } else {
       counter --;
     }
     //Serial.print("Position: ");
     //Serial.println(counter);
   } 
   aLastState = aState; // Updates the previous state of the outputA with the current state
   lastCounter = counter;
}

void display1()
{
  while(!digitalRead(16))
  {
      counter=pullSpeed;
      encRead();
      pullSpeed=counter;
      if(counter>4){counter=1;}
      if(counter<1){counter=4;}
      pullSpeed=counter;
      if(lastCounter != counter){u8g2.clearDisplay();}
      String speedDisp = " >Speed :";
      speedDisp += String(pullSpeed);
      speedDisp += " mm/s";
      u8x8.drawString(0,2,speedDisp.c_str());
      String lengthDisp = "  Length:";
      lengthDisp += String(lengthCatheter);
      lengthDisp += " mm";
      u8x8.drawString(0,3,lengthDisp.c_str());
      u8x8.drawString(0,4,"  Run!");
  }
    counter = 0;
    if(lastCounter != counter){u8g2.clearDisplay();}
    String speedDisp = " >Speed :";
    speedDisp += String(pullSpeed);
    speedDisp += "mm/s";
    u8x8.drawString(0,2,speedDisp.c_str());
    String lengthDisp = "  Length:";
    lengthDisp += String(lengthCatheter);
    lengthDisp += "mm";
    u8x8.drawString(0,3,lengthDisp.c_str());
    u8x8.drawString(0,4,"  Run!");
}


void display2()
{
  while(!digitalRead(16))
  {
      counter=lengthCatheter;
      encRead();
      lengthCatheter=counter;
      if(lastCounter != counter){u8g2.clearDisplay();}
      String speedDisp = "  Speed :";
      speedDisp += String(pullSpeed);
      speedDisp += " mm/s";
      u8x8.drawString(0,2,speedDisp.c_str());
      String lengthDisp = " >Length:";
      lengthDisp += String(lengthCatheter);
      lengthDisp += " mm";
      u8x8.drawString(0,3,lengthDisp.c_str());
      u8x8.drawString(0,4,"  Run!");
  }
    counter = 1;
    if(lastCounter != counter){u8g2.clearDisplay();}
    String speedDisp = "  Speed :";
    speedDisp += String(pullSpeed);
    speedDisp += "mm/s";
    u8x8.drawString(0,2,speedDisp.c_str());
    String lengthDisp = " >Length:";
    lengthDisp += String(lengthCatheter);
    lengthDisp += "mm";
    u8x8.drawString(0,3,lengthDisp.c_str());
    u8x8.drawString(0,4,"  Run!");
}

void display3()
{
    if(lastCounter != counter){u8g2.clearDisplay();}
    String speedDisp = "  Speed :";
    speedDisp += String(pullSpeed);
    speedDisp += "mm/s";
    u8x8.drawString(0,2,speedDisp.c_str());
    String lengthDisp = "  Length:";
    lengthDisp += String(lengthCatheter);
    lengthDisp += "mm";
    u8x8.drawString(0,3,lengthDisp.c_str());
    u8x8.drawString(0,4," >Run!");  

    if(!digitalRead(16))
  {
    analogWrite(19,0);
    analogWrite(18,50*pullSpeed);
    delay((lengthCatheter/pullSpeed)*1000);
    analogWrite(19,0);
    analogWrite(18,0);
  }
}

void mainProgram()
{
   readSwitch();
   encRead();
   switch (counter)
    {
    case 0:
      display1();
      break;
    case 1:
      display2();
      break;
    case 2:
      display3();
      break;
    
    default:
      if(counter>2){counter=0;}
      else{counter=2;}
      break;
    }
}

void setup(void)
{
  pinMode(18,OUTPUT);
  pinMode(19,OUTPUT);
  pinMode(16,INPUT_PULLUP); //SW
  pinMode(2,INPUT_PULLUP); //CLK
  pinMode(4,INPUT_PULLUP); //DT
  Serial.begin(115200);
  aLastState = digitalRead(encUA); 
  u8g2.begin();
  u8x8.begin();
  u8x8.setPowerSave(0);
  u8x8.setFont(u8x8_font_chroma48medium8_r);
  u8g2.clearBuffer();
  //u8x8.drawString(0,3," Vascular");
  //u8x8.drawString(0,4," Indoneisa!");
  u8g2.drawXBMP(34,0,60,60,myBitmapRev);
  u8g2.sendBuffer();
  //u8x8.refreshDisplay();		// only required for SSD1606/7  
  delay(2000);
  Serial.println("Booting");
  WiFi.mode(WIFI_STA);
  WiFi.begin(ssid, password);
  while (WiFi.waitForConnectResult() != WL_CONNECTED) {
    Serial.println("Connection Failed! Rebooting...");
    delay(5000);
    ESP.restart();
  }
  ArduinoOTA
    .onStart([]() {
      String type;
      if (ArduinoOTA.getCommand() == U_FLASH)
        type = "sketch";
      else // U_SPIFFS
        type = "filesystem";

      // NOTE: if updating SPIFFS this would be the place to unmount SPIFFS using SPIFFS.end()
      Serial.println("Start updating " + type);
    })
    .onEnd([]() {
      Serial.println("\nEnd");
    })
    .onProgress([](unsigned int progress, unsigned int total) {
      Serial.printf("Progress: %u%%\r", (progress / (total / 100)));
    })
    .onError([](ota_error_t error) {
      Serial.printf("Error[%u]: ", error);
      if (error == OTA_AUTH_ERROR) Serial.println("Auth Failed");
      else if (error == OTA_BEGIN_ERROR) Serial.println("Begin Failed");
      else if (error == OTA_CONNECT_ERROR) Serial.println("Connect Failed");
      else if (error == OTA_RECEIVE_ERROR) Serial.println("Receive Failed");
      else if (error == OTA_END_ERROR) Serial.println("End Failed");
    });

  ArduinoOTA.begin();
  Serial.println("Ready");
  Serial.print("IP address: ");
  Serial.println(WiFi.localIP());
  u8g2.clearBuffer();
  u8g2.clearDisplay();
  u8x8.drawString(0,3," Vascular");
  u8x8.drawString(0,4," Indoneisa!");
  delay(1000);
  u8g2.clearDisplay();
  u8x8.drawString(0,2," >Speed  : ");
  u8x8.drawString(0,3,"  Length : ");
  u8x8.drawString(0,4,"  Run!");
  // This tells the library that the encoder has its own pull-up resistors
	rotaryEncoder.setEncoderType( EncoderType::HAS_PULLUP );

	// Range of values to be returned by the encoder: minimum is 1, maximum is 10
	// The third argument specifies whether turning past the minimum/maximum will
	// wrap around to the other side:
	//  - true  = turn past 10, wrap to 1; turn past 1, wrap to 10
	//  - false = turn past 10, stay on 10; turn past 1, stay on 1
	// rotaryEncoder.setBoundaries( 1, 1000, true );

	// The function specified here will be called every time the knob is turned
	// and the current value will be passed to it
	rotaryEncoder.onTurned( &knobCallback );

	// This is where the inputs are configured and the interrupts get attached
	rotaryEncoder.begin();
}

void loop(void)
{
  ArduinoOTA.handle();
  mainProgram();
}